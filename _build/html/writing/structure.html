

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>结构化您的工程 &mdash; The Hitchhiker&#39;s Guide to Python</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="代码风格" href="style.html" />
    <link rel="prev" title="虚拟环境" href="../dev/venv.html" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    div.body {
      min-width: initial;
      max-width: initial;
    }
  </style>

  
  <link rel="canonical" href="https://docs.python-guide.org/writing/structure/"/>
  <meta property="og:url" content="https://docs.python-guide.org/writing/structure">
  

  <link rel="icon" type="image/png" href="https://media.readthedocs.org/images/favicon.png">

  <meta name="google-site-verification" content="013PxE2_8KX9jdUSC5gr8QsfdxTXr1mFgmD9zplp5II" />

  <meta name="twitter:card" content="summary">
  <meta property="twitter:image" content="https://docs.python-guide.org/_static/social-card.jpg">
  <meta property="og:image" content="https://docs.python-guide.org/_static/social-card.jpg">
  <meta property="og:title" content="结构化您的工程 &mdash; The Hitchhiker&#39;s Guide to Python">
  <meta property="og:type" content="article">
  
  <meta property="og:description" content="">

  <script>window.rp_prop_id = '29182759436';</script>
  <script src="https://srv.realpython.net/tag.js" async></script>

  <script src="https://d31vxm9ubutrmw.cloudfront.net/static/js/2169.js"></script>

  
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-37242602-11', 'auto');
    ga('send', 'pageview');
    </script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pythonguide
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../starting/win.html">在Windows上安装Python 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../starting/linux.html">在Linux上安装Python 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../starting/pip.html">Pip使用</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/env.html">您的开发环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/venv.html">虚拟环境</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">结构化您的工程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">仓库的结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">这很重要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">仓库样例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">真正的模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#license">License</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setup-py">Setup.py</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirements-file">Requirements File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#documentation">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-suite">Test Suite</a></li>
<li class="toctree-l3"><a class="reference internal" href="#makefile">Makefile</a></li>
<li class="toctree-l3"><a class="reference internal" href="#django-applications">关于 Django Applications</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">结构是一把钥匙</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">包</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">面向对象编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">装饰器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">内置装饰器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">函数装饰器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">装饰器和函数都不带参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">装饰带参数的函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id17">上下文管理器</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">动态类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19">可变和不可变类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id20">提供依赖关系</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runners">Runners</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">更多阅读</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="style.html">代码风格</a></li>
<li class="toctree-l1"><a class="reference internal" href="reading.html">阅读好的代码</a></li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">类型系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">测试您的代码</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">日志（Logging）</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Python%E8%BF%9B%E9%98%B6/index.html">Python进阶</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%84%E4%BB%B6/index.html">组件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">工具类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demos/numpy-style.html">Numpy style风格的注释文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%9F%A5%E8%AF%86%E7%82%B9.html">知识点</a></li>
<li class="toctree-l1"><a class="reference internal" href="../awesome/index.html">awesome库</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/index.html">项目工具</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pythonguide</a>
        
      </nav>


      <div class="wy-nav-content">

        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>结构化您的工程</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            <div style="display:block;position:relative; margin-bottom: 1em;">
              <div style="display:block;width:100%;padding-top:12.5%;"></div>
              <div class="rpad" data-unit="8x1" style="position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;"></div>
            </div>
            
  <div class="section" id="id1">
<h1>结构化您的工程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<img alt="https://farm5.staticflickr.com/4203/33907151224_0574e7dfc2_k_d.jpg" src="https://farm5.staticflickr.com/4203/33907151224_0574e7dfc2_k_d.jpg" />
<p>我们对于“结构化”的定义是您关注于怎样使您的项目最好地满足它的对象性，我们
需要去考虑如何更好地利用Python的特性来创造简洁、高效的代码。在实践层面，
“结构化”意味着通过编写简洁的代码，并且正如文件系统中文件和目录的组织一样，
代码应该使逻辑和依赖清晰。</p>
<p>哪个函数应该放到哪个模块？数据在项目中如何流转？什么功能和函数应该组合
或独立？要解决这些问题，您可以开始做一个计划，大体来说，即是您的最终产品
看起来会是怎样的。</p>
<p>在这一章节中，我们更深入地去观察Python的模块和导入系统，因为它们是加强您
的项目结构化的关键因素，接着我们会从不同层面去讨论如何去构建可扩展且测试
可靠的代码。</p>
<div class="section" id="id2">
<h2>仓库的结构<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>这很重要<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>在一个健康的开发周期中，代码风格，API设计和自动化是非常关键的。同样的，对于工程的 <a class="reference external" href="http://www.amazon.com/gp/product/1257638017/ref=as_li_ss_tl?ie=UTF8&amp;tag=bookforkind-20&amp;linkCode=as2&amp;camp=1789&amp;creative=39095&amp;creativeASIN=1257638017">架构</a> ,仓库的结构也是关键的一部分。</p>
<p>当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:</p>
<ul class="simple">
<li><p>工程的名字</p></li>
<li><p>工程的描述</p></li>
<li><p>一系列的文件</p></li>
</ul>
<p>只有当他们滚动到目录下方时才会看到您工程的README。</p>
<p>如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。</p>
<blockquote>
<div><p>为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。</p>
</div></blockquote>
<p>当然，第一印象并不是一切。但是，您和您的同事会和这个仓库并肩战斗很长时间，会熟悉它的每一个角落和细节。拥有良好的布局，事半功倍。</p>
</div>
<div class="section" id="id5">
<h3>仓库样例<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p><strong>请看这里</strong>: 这是 <a class="reference external" href="https://www.kennethreitz.org/essays/repository-structure-and-python">Kenneth Reitz在2013年推荐的</a> 。</p>
<p>这个仓库 <a class="reference external" href="https://github.com/kennethreitz/samplemod">可以在GitHub上找到</a> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">README</span><span class="o">.</span><span class="n">rst</span>
<span class="n">LICENSE</span>
<span class="n">setup</span><span class="o">.</span><span class="n">py</span>
<span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>
<span class="n">sample</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
<span class="n">sample</span><span class="o">/</span><span class="n">core</span><span class="o">.</span><span class="n">py</span>
<span class="n">sample</span><span class="o">/</span><span class="n">helpers</span><span class="o">.</span><span class="n">py</span>
<span class="n">docs</span><span class="o">/</span><span class="n">conf</span><span class="o">.</span><span class="n">py</span>
<span class="n">docs</span><span class="o">/</span><span class="n">index</span><span class="o">.</span><span class="n">rst</span>
<span class="n">tests</span><span class="o">/</span><span class="n">test_basic</span><span class="o">.</span><span class="n">py</span>
<span class="n">tests</span><span class="o">/</span><span class="n">test_advanced</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>让我们看一下细节。</p>
</div>
<div class="section" id="id6">
<h3>真正的模块<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./sample/</span></code> or <code class="docutils literal notranslate"><span class="pre">./sample.py</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>核心代码</p></td>
</tr>
</tbody>
</table>
<p>您的模块包是这个仓库的核心，它不应该隐藏起来:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">sample</span><span class="o">/</span>
</pre></div>
</div>
<p>如果您的模块只有一个文件，那么您可以直接将这个文件放在仓库的根目录下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">sample</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>这个模块文件不应该属于任何一个模棱两可的src或者python子目录。</p>
</div>
<div class="section" id="license">
<h3>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./LICENSE</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>许可证.</p></td>
</tr>
</tbody>
</table>
<p>除了源代码本身以外，这个毫无疑问是您仓库最重要的一部分。在这个文件中要有完整的许可说明和授权。</p>
<p>如果您不太清楚您应该使用哪种许可方式，请查看 <a class="reference external" href="http://choosealicense.com">choosealicense.com</a>.</p>
<p>当然，您也可以在发布您的代码时不做任何许可说明，但是这显然阻碍潜在的用户使用您的代码。</p>
</div>
<div class="section" id="setup-py">
<h3>Setup.py<a class="headerlink" href="#setup-py" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./setup.py</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>打包和发布管理</p></td>
</tr>
</tbody>
</table>
<p>如果您的模块包在您的根目录下，显然这个文件也应该在根目录下。</p>
</div>
<div class="section" id="requirements-file">
<h3>Requirements File<a class="headerlink" href="#requirements-file" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./requirements.txt</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>开发依赖.</p></td>
</tr>
</tbody>
</table>
<p>一个 <a class="reference external" href="https://pip.pypa.io/en/stable/user_guide/#requirements-files">pip requirements file</a> 应该放在仓库的根目录。它应该指明完整工程的所有依赖包: 测试, 编译和文档生成。</p>
<p>如果您的工程没有任何开发依赖，或者您喜欢通过 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 来设置，那么这个文件不是必须的。</p>
</div>
<div class="section" id="documentation">
<h3>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./docs/</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>包的参考文档</p></td>
</tr>
</tbody>
</table>
<p>没有任何理由把这个放到别的地方。</p>
</div>
<div class="section" id="test-suite">
<h3>Test Suite<a class="headerlink" href="#test-suite" title="Permalink to this headline">¶</a></h3>
<p><em>想了解关于编写测试的建议，请查阅</em> <a class="reference internal" href="tests.html"><span class="doc">测试您的代码</span></a>。</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./test_sample.py</span></code> or <code class="docutils literal notranslate"><span class="pre">./tests</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>包的集合和单元测试</p></td>
</tr>
</tbody>
</table>
<p>最开始，一组测试例子只是放在一个文件当中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">test_sample</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>当测试例子逐步增加时，您会把它放到一个目录里面，像下面这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span><span class="n">test_basic</span><span class="o">.</span><span class="n">py</span>
<span class="n">tests</span><span class="o">/</span><span class="n">test_advanced</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>当然，这些测试例子需要导入您的包来进行测试，有几种方式来处理:</p>
<ul class="simple">
<li><p>将您的包安装到site-packages中。</p></li>
<li><p>通过简单直接的路径设置来解决导入的问题。</p></li>
</ul>
<p>我极力推荐后者。如果使用 <code class="docutils literal notranslate"><span class="pre">setup.py</span> <span class="pre">develop</span></code> 来测试一个持续更新的代码库，需要为每一个版本的代码库设置一个独立的测试环境.太麻烦了。</p>
<p>可以先创建一个包含上下文环境的文件 <code class="docutils literal notranslate"><span class="pre">tests/context.py</span></code>。
file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;..&#39;</span><span class="p">)))</span>

<span class="kn">import</span> <span class="nn">sample</span>
</pre></div>
</div>
<p>然后，在每一个测试文件中，导入:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.context</span> <span class="kn">import</span> <span class="n">sample</span>
</pre></div>
</div>
<p>这样就能够像期待的那样工作，而不用采用安装的方式。</p>
<p>一些人会说应该把您的测试例子放到您的模块里面 – 我不同意。这样会增加您用户使用的复杂度；而且添加测试模块将导致需要额外的依赖和运行环境。</p>
</div>
<div class="section" id="makefile">
<h3>Makefile<a class="headerlink" href="#makefile" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>布局</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./Makefile</span></code></p></td>
</tr>
<tr class="row-even"><td><p>作用</p></td>
<td><p>常规的管理任务</p></td>
</tr>
</tbody>
</table>
<p>如果您看看我的项目或者其他开源项目，您都会发现有一个Makefile。为什么？这些项目也不是用C写的啊。。。简而言之，make对于定义常规的管理任务是非常有用的工具。</p>
<p>** 样例 Makefile:**</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">init</span><span class="p">:</span>
    <span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">r</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>

<span class="n">test</span><span class="p">:</span>
    <span class="n">py</span><span class="o">.</span><span class="n">test</span> <span class="n">tests</span>

<span class="n">PHONY</span><span class="p">:</span> <span class="n">init</span> <span class="n">test</span>
</pre></div>
</div>
<p>一些其他的常规管理脚本（比如 <code class="docutils literal notranslate"><span class="pre">manage.py</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">fabfile.py</span></code>），也放在仓库的根目录下。</p>
</div>
<div class="section" id="django-applications">
<h3>关于 Django Applications<a class="headerlink" href="#django-applications" title="Permalink to this headline">¶</a></h3>
<p>从Django 1.4开始，我发现有这样一个现象：很多开发者错误地使用Django自带的应用模板创建项目，导致他们的仓库结构非常糟糕。</p>
<p>这是怎么回事儿? 是的, 他们在进入一个新的仓库后，通常都这样操作：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ django-admin.py startproject samplesite
</pre></div>
</div>
<p>这样的操作生成的仓库结构是这样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">README</span><span class="o">.</span><span class="n">rst</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">manage</span><span class="o">.</span><span class="n">py</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">samplesite</span><span class="o">/</span><span class="n">settings</span><span class="o">.</span><span class="n">py</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">samplesite</span><span class="o">/</span><span class="n">wsgi</span><span class="o">.</span><span class="n">py</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">samplesite</span><span class="o">/</span><span class="n">sampleapp</span><span class="o">/</span><span class="n">models</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>亲，不要这样做。</p>
<p>相对路径会让您的工具和您的开发者都很疑惑。没有必要的嵌套对任何人都没有好处（除非您怀念庞大的SVN仓库）。</p>
<p>让我们这样来做:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ django-admin.py startproject samplesite .
</pre></div>
</div>
<p>注意末尾的 “<code class="docutils literal notranslate"><span class="pre">.</span></code>”。</p>
<p>生成的结构是这样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">README</span><span class="o">.</span><span class="n">rst</span>
<span class="n">manage</span><span class="o">.</span><span class="n">py</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">settings</span><span class="o">.</span><span class="n">py</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">wsgi</span><span class="o">.</span><span class="n">py</span>
<span class="n">samplesite</span><span class="o">/</span><span class="n">sampleapp</span><span class="o">/</span><span class="n">models</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>结构是一把钥匙<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>得益于Python提供的导入与管理模块的方式，结构化Python项目变得相对简单。
这里说的简单，指的是结构化过程没有太多约束限制而且模块导入功能容易掌握。
因而您只剩下架构性的工作，包括设计、实现项目各个模块，并整理清他们之间
的交互关系。</p>
<p>容易结构化的项目同样意味着它的结构化容易做得糟糕。糟糕结构的特征包括：</p>
<ul class="simple">
<li><p>多重且混乱的循环依赖关系：假如在 <code class="file docutils literal notranslate"><span class="pre">furn.py</span></code> 内的Table与Chair类需要
导入 <code class="file docutils literal notranslate"><span class="pre">workers.py</span></code> 中的Carpenter类以回答类似 <code class="docutils literal notranslate"><span class="pre">table.isdoneby()</span></code>
的问题，并且Carpenter类需要引入Table和Chair类以回答 <code class="docutils literal notranslate"><span class="pre">carpenter.whatdo()</span></code>
这类问题，这就是一种循环依赖的情况。在这种情况下,您得借助一些不怎么靠谱的
小技巧，比如在方法或函数内部使用import语句。</p></li>
<li><p>隐含耦合：Table类实现代码中每一个改变都会打破20个不相关的测试用例，由于它
影响了Carpenter类的代码，这要求谨慎地操作以适应改变。这样的情况意味着
Carpenter类代码中包含了太多关于Table类的假设关联（或相反）。</p></li>
<li><p>大量使用全局变量或上下文：如果Table和Carpenter类使用不仅能被修改而且能被
不同引用修改的全局变量，而不是明确地传递 <code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">width,</span> <span class="pre">type,</span> <span class="pre">wood)</span></code>
变量。您就需要彻底检查全局变量的所有入口，来理解到为什么一个长方形桌子变
成了正方形，最后发现远程的模板代码修改了这份上下文，弄错了桌子尺寸规格的
定义。</p></li>
<li><p>面条式代码 (Spaghetti code) ：多页嵌套的if语句与for循环，包含大量复制-粘贴
的过程代码，且没有合适的分割——这样的代码被称为面条式代码。Python中有意思
的缩进排版(最具争议的特性之一)使面条式代码很难维持。所以好消息是您也许不
会经常看到这种面条式代码。</p></li>
<li><p>Python中更可能出现混沌代码：这类代码包含上百段相似的逻辑碎片，通常是缺乏
合适结构的类或对象，如果您始终弄不清手头上的任务应该使用FurnitureTable，
AssetTable还是Table，甚至TableNew，也许您已经陷入了混沌代码中。</p></li>
</ul>
</div>
<div class="section" id="id8">
<h2>模块<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Python模块是最主要的抽象层之一，并且很可能是最自然的一个。抽象层允许将代码分为
不同部分，每个部分包含相关的数据与功能。</p>
<p>例如在项目中，一层控制用户操作相关接口，另一层处理底层数据操作。最自然分开这两
层的方式是，在一份文件里重组所有功能接口，并将所有底层操作封装到另一个文件中。
这种情况下，接口文件需要导入封装底层操作的文件，可通过 <code class="docutils literal notranslate"><span class="pre">import</span></code> 和
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> 语句完成。一旦您使用 <cite>import</cite> 语句，就可以使用这个模块。
既可以是内置的模块包括 <cite>os</cite> 和 <cite>sys</cite>，也可以是已经安装的第三方的模块，或者项目
内部的模块。</p>
<p>为遵守风格指南中的规定，模块名称要短、使用小写，并避免使用特殊符号，比如点(.)
和问号(?)。如 <code class="file docutils literal notranslate"><span class="pre">my.spam.py</span></code> 这样的名字是必须不能用的！该方式命名将妨碍
Python的模块查找功能。就 <cite>my.spam.py</cite> 来说，Python 认为需要在 <code class="file docutils literal notranslate"><span class="pre">my</span></code> 文件夹
中找到 <code class="file docutils literal notranslate"><span class="pre">spam.py</span></code> 文件，实际并不是这样。这个例子
<a class="reference external" href="http://docs.python.org/tutorial/modules.html#packages">example</a> 展示了点表示
法应该如何在Python文件中使用。如果愿意您可以将模块命名为 <code class="file docutils literal notranslate"><span class="pre">my_spam.py</span></code>，
不过并不推荐在模块名中使用下划线。但是，在模块名称中使用其他字符（空格或连字号）
将阻止导入（-是减法运算符），因此请尽量保持模块名称简单，以无需分开单词。
最重要的是，不要使用下划线命名空间，而是使用子模块。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># OK</span>
<span class="kn">import</span> <span class="nn">library.plugin.foo</span>
<span class="c1"># not OK</span>
<span class="kn">import</span> <span class="nn">library.foo_plugin</span>
</pre></div>
</div>
<p>除了以上的命名限制外，Python文件成为模块没有其他特殊的要求，但为了合理地使用这
个观念并避免问题，您需要理解import的原理机制。具体来说，<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">modu</span></code> 语句将
寻找合适的文件，即调用目录下的 <code class="file docutils literal notranslate"><span class="pre">modu.py</span></code> 文件（如果该文件存在）。如果没有
找到这份文件，Python解释器递归地在 “PYTHONPATH” 环境变量中查找该文件，如果仍没
有找到，将抛出ImportError异常。</p>
<p>一旦找到 <code class="file docutils literal notranslate"><span class="pre">modu.py</span></code>，Python解释器将在隔离的作用域内执行这个模块。所有顶层
语句都会被执行，包括其他的引用。方法与类的定义将会存储到模块的字典中。然后，这个
模块的变量、方法和类通过命名空间暴露给调用方，这是Python中特别有用和强大的核心概念。</p>
<p>在很多其他语言中，<code class="docutils literal notranslate"><span class="pre">include</span> <span class="pre">file</span></code> 指令被预处理器用来获取文件里的所有代码并‘复制’
到调用方的代码中。Python则不一样：include代码被独立放在模块命名空间里，这意味着您
一般不需要担心include的代码可能造成不好的影响，例如重载同名方法。</p>
<p>也可以使用import语句的特殊形式 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modu</span> <span class="pre">import</span> <span class="pre">*</span></code> 模拟更标准的行为。但 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code> 通常
被认为是不好的做法。<strong>使用</strong> <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modu</span> <span class="pre">import</span> <span class="pre">*</span></code> <strong>的代码较难阅读而且依赖独立性不足</strong>。
使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modu</span> <span class="pre">import</span> <span class="pre">func</span></code> 能精确定位您想导入的方法并将其放到本地命名空间中。
比 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modu</span> <span class="pre">import</span> <span class="pre">*</span></code> 要好些，因为它明确地指明往本地命名空间中导入了什么方法，它和
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">modu</span></code> 相比唯一的优点是之后使用方法时可以少打点儿字。</p>
<p><strong>差</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="kn">from</span> <span class="nn">modu</span> <span class="kn">import</span> <span class="o">*</span>
<span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># sqrt是模块modu的一部分么？或是内建函数么？上文定义了么？</span>
</pre></div>
</div>
<p><strong>稍好</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">modu</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># 如果在import语句与这条语句之间，sqrt没有被重复定义，它也许是模块modu的一部分。</span>
</pre></div>
</div>
<p><strong>最好的做法</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">modu</span>
<span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">modu</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># sqrt显然是属于模块modu的。</span>
</pre></div>
</div>
<p>在 <a class="reference internal" href="style.html#code-style"><span class="std std-ref">代码风格</span></a> 章节中提到，可读性是Python最主要的特性之一。可读性意味着避免
无用且重复的文本和混乱的结构，因而需要花费一些努力以实现一定程度的简洁。但不能
过份简洁而导致简短晦涩。除了简单的单文件项目外，其他项目需要能够明确指出类和方法
的出处，例如使用 <code class="docutils literal notranslate"><span class="pre">modu.func</span></code> 语句，这将显著提升代码的可读性和易理解性。</p>
</div>
<div class="section" id="id9">
<h2>包<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Python提供非常简单的包管理系统，即简单地将模块管理机制扩展到一个目录上(目录扩
展为包)。</p>
<p>任意包含 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件的目录都被认为是一个Python包。导入一个包里不同
模块的方式和普通的导入模块方式相似，特别的地方是 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件将集合
所有包范围内的定义。</p>
<p><code class="file docutils literal notranslate"><span class="pre">pack/</span></code> 目录下的 <code class="file docutils literal notranslate"><span class="pre">modu.py</span></code> 文件通过 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">pack.modu</span></code> 语句导入。
该语句会在 <code class="file docutils literal notranslate"><span class="pre">pack</span></code> 目录下寻找 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件，并执行其中所有顶层
语句。以上操作之后，<code class="file docutils literal notranslate"><span class="pre">modu.py</span></code> 内定义的所有变量、方法和类在pack.modu命名空
间中均可看到。</p>
<p>一个常见的问题是往 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 中加了过多代码，随着项目的复杂度增长，
目录结构越来越深，子包和更深嵌套的子包可能会出现。在这种情况下，导入多层嵌套
的子包中的某个部件需要执行所有通过路径里碰到的 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件。如果
包内的模块和子包没有代码共享的需求，使用空白的 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件是正常
甚至好的做法。</p>
<p>最后，导入深层嵌套的包可用这个方便的语法：<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">very.deep.module</span> <span class="pre">as</span> <span class="pre">mod</span></code>。
该语法允许使用 <cite>mod</cite> 替代冗长的 <code class="docutils literal notranslate"><span class="pre">very.deep.module</span></code>。</p>
</div>
<div class="section" id="id10">
<h2>面向对象编程<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>Python有时被描述为面向对象编程的语言，这多少是个需要澄清的误导。在Python中
一切都是对象，并且能按对象的方式处理。这么说的意思是，例如函数是一等对象。
函数、类、字符串乃至类型都是Python对象：与其他对象一样，他们有类型，能作为
函数参数传递，并且还可能有自己的方法和属性。这样理解的话，Python是一种面向
对象语言。</p>
<p>然而，与Java不同的是，Python并没有将面向对象编程作为最主要的编程范式。非面向
对象的Python项目(比如，使用较少甚至不使用类定义，类继承，或其它面向对象编程的
机制)也是完全可行的。</p>
<p>此外在 <a class="reference internal" href="#id8">模块</a> 章节里曾提到，Python管理模块与命名空间的方式提供给开发者一个自然
的方式以实现抽象层的封装和分离，这是使用面向对象最常见的原因。因而，如果业务逻辑
没有要求，Python开发者有更多自由去选择不使用面向对象。</p>
<p>在一些情况下，需要避免不必要的面向对象。当我们想要将状态与功能结合起来，使用
标准类定义是有效的。但正如函数式编程所讨论的那个问题，函数式的“变量”状态与类的
状态并不相同。</p>
<p>在某些架构中，典型代表是web应用，大量Python进程实例被产生以响应可能同时到达的
外部请求。在这种情况下，在实例化对象内保持某些状态，即保持某些环境静态信息，
容易出现并发问题或竞态条件。有时候在对象状态的初始化(通常通过 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>
方法实现)和在其方法中使用该状态之间，环境发生了变化，保留的状态可能已经过时。
举个例子，某个请求将对象加载到内存中并标记它为已读。如果同时另一个请求要删除
这个对象，删除操作可能刚好发生在第一个请求加载完该对象之后，结果就是第一个请
求标记了一个已经被删除的对象为已读。</p>
<p>这些问题使我们产生一个想法：使用无状态的函数是一种更好的编程范式。另一种建议
是尽量使用隐式上下文和副作用较小的函数与程序。函数的隐式上下文由函数内部访问
到的所有全局变量与持久层对象组成。副作用即函数可能使其隐式上下文发生改变。如
果函数保存或删除全局变量或持久层中数据，这种行为称为副作用。</p>
<p>把有隐式上下文和副作用的函数与仅包含逻辑的函数(纯函数)谨慎地区分开来，会带来
以下好处：</p>
<ul class="simple">
<li><p>纯函数的结果是确定的：给定一个输入，输出总是固定相同。</p></li>
<li><p>当需要重构或优化时，纯函数更易于更改或替换。</p></li>
<li><p>纯函数更容易做单元测试：很少需要复杂的上下文配置和之后的数据清除工作。</p></li>
<li><p>纯函数更容易操作、修饰和分发。</p></li>
</ul>
<p>总之，对于某些架构而言，纯函数比类和对象在构建模块时更有效率，因为他们没有任何
上下文和副作用。但显然在很多情况下，面向对象编程是有用甚至必要的。例如图形桌面
应用或游戏的开发过程中，操作的元素(窗口、按钮、角色、车辆)在计算机内存里拥有相
对较长的生命周期。</p>
</div>
<div class="section" id="id11">
<h2>装饰器<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">定义</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/glossary.html#term-decorator">https://docs.python.org/zh-cn/3/glossary.html#term-decorator</a></p>
</dd>
</dl>
<p>Python语言提供一个简单而强大的语法: ‘装饰器’。装饰器是一个函数或类，它可以
包装(或装饰)一个函数或方法。被 ‘装饰’ 的函数或方法会替换原来的函数或方法。
由于在Python中函数是一等对象，它也可以被 ‘手动操作’，但是使用&#64;decorators
语法更清晰，因此首选这种方式。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="c1"># 实现语句</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="c1"># 操作func语句</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>  <span class="c1"># 手动装饰</span>

<span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="c1"># 实现语句</span>
<span class="c1"># bar()被装饰了</span>
</pre></div>
</div>
<p>这个机制对于分离概念和避免外部不相关逻辑“污染”主要逻辑很有用处。
<a class="reference external" href="https://en.wikipedia.org/wiki/Memoization#Overview">记忆化</a> 或缓存就是一个很
好的使用装饰器的例子：您需要在table中储存一个耗时函数的结果，并且下次能直接
使用该结果，而不是再计算一次。这显然不属于函数的逻辑部分。</p>
<div class="section" id="id13">
<h3>内置装饰器<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#property">&#64;property</a> 返回 property 属性。</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#classmethod">&#64;classmethod</a> 把一个方法封装成类方法。</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#staticmethod">staticmethod</a> 将方法转换为静态方法。</p></li>
</ul>
<p>&#64;property装饰器可以总结为两个作用：
- 让函数可以像普通变量一样使用
- 对要读取的数据进行预处理</p>
<p>&#64;*.setter装饰器可以总结为两个作用：
- 对要存入的数据进行预处理
- 设置可读属性(不可修改)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>&#64;*.setter装饰器必须在&#64;property装饰器的后面，且两个被修饰的函数的名称必须保持一致，* 即为函数名称。</p>
</div>
<p>示例 通过&#64;*.setter装饰器，我们可以方便的设置只读属性，即无法对属性进行修改:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">():</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_age</span> <span class="o">=</span> <span class="n">age</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age</span>
<span class="nd">@age</span><span class="o">.</span><span class="n">setter</span>
<span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_age</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">5</span>

<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s1">&#39;xiao&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">user</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">5</span>

<span class="nb">print</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
<span class="c1"># 【output】10</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>关于类方法和静态方法，如果要调用类的属性或者实例化对象，使用&#64;classmethod，不涉及到类的属性则应该使用&#64;staticmethod</p>
</div>
</div>
<div class="section" id="id14">
<h3>函数装饰器<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id15">
<h4>装饰器和函数都不带参数<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">deco</span><span class="p">():</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">deco</span>

<span class="nd">@timer</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test is running!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h4>装饰带参数的函数<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>明确参数的写法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">w_say</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    如果原函数有参数，那闭包函数必须保持参数个数一致，并且将参数传递给原方法</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        如果被装饰的函数有行参，那么闭包函数必须有参数</span>
<span class="sd">        :param name:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;say inner called&#39;</span><span class="p">)</span>
        <span class="n">fun</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@w_say</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello &#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
<span class="n">hello</span><span class="p">(</span><span class="s1">&#39;wangcai&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>不定参数的写法</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">w_add</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;add inner called&#39;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>
<span class="nd">@w_add</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> + </span><span class="si">%d</span><span class="s1"> = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span>
<span class="nd">@w_add</span>
<span class="k">def</span> <span class="nf">add2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> + </span><span class="si">%d</span><span class="s1"> + </span><span class="si">%d</span><span class="s1"> = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span>
<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">add2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id17">
<h2>上下文管理器<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>上下文管理器是一个Python对象，为操作提供了额外的上下文信息。 这种额外的信息，
在使用 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句初始化上下文，以及完成 <code class="docutils literal notranslate"><span class="pre">with</span></code> 块中的所有代码时，采用可调用的形式。
这里展示了使用上下文管理器的为人熟知的示例，打开文件：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;file.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>任何熟悉这种模式的人都知道以这种形式调用 <code class="docutils literal notranslate"><span class="pre">open</span></code> 能确保 <code class="docutils literal notranslate"><span class="pre">f`</span> <span class="pre">的</span> <span class="pre">``close</span></code> 方法会在某个时候被调用。
这样可以减少开发人员的认知负担，并使代码更容易阅读。</p>
<p>实现这个功能有两种简单的方法：使用类或使用生成器。 让我们自己实现上面的功能，以使用类方式开始：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomOpen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx_type</span><span class="p">,</span> <span class="n">ctx_value</span><span class="p">,</span> <span class="n">ctx_traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">with</span> <span class="n">CustomOpen</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>这只是一个常规的Python对象，它有两个由 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句使用的额外方法。
CustomOpen 首先被实例化，然后调用它的`__enter__``方法，而且 <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> 的返回值在
<code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">f</span></code> 语句中被赋给 <code class="docutils literal notranslate"><span class="pre">f</span></code> 。 当 <code class="docutils literal notranslate"><span class="pre">with</span></code> 块中的内容执行完后，会调用 <cite>__exit__`</cite> 方法。</p>
<p>而生成器方式使用了Python自带的
<a class="reference external" href="https://docs.python.org/3/library/contextlib.html">contextlib</a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">custom_open</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">f</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">with</span> <span class="n">custom_open</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>这与上面的类示例道理相通，尽管它更简洁。<code class="docutils literal notranslate"><span class="pre">custom_open</span></code> 函数一直运行到 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 语句。
然后它将控制权返回给 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句，然后在 <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">f</span></code> 部分将yield的 <cite>f</cite> 赋值给f。
<code class="docutils literal notranslate"><span class="pre">finally</span></code> 确保不论 <code class="docutils literal notranslate"><span class="pre">with</span></code> 中是否发生异常， <code class="docutils literal notranslate"><span class="pre">close()</span></code> 都会被调用。</p>
<p>由于这两种方法都是一样的，所以我们应该遵循Python之禅来决定何时使用哪种。
如果封装的逻辑量很大，则类的方法可能会更好。 而对于处理简单操作的情况，函数方法可能会更好。</p>
</div>
<div class="section" id="id18">
<h2>动态类型<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>Python是动态类型语言，这意味着变量并没有固定的类型。实际上，Python 中的变量和其他
语言有很大的不同，特别是静态类型语言。变量并不是计算机内存中被写入的某个值，它们
只是指向内存的 ‘标签’ 或 ‘名称’ 。因此可能存在这样的情况，变量 ‘a’ 先代表值1，然后变成
字符串 ‘a string’ , 然后又变为指向一个函数。</p>
<p>Python 的动态类型常被认为是它的缺点，的确这个特性会导致复杂度提升和难以调试的代码。
命名为 ‘a’ 的变量可能是各种类型，开发人员或维护人员需要在代码中追踪命名，以保证它
没有被设置到毫不相关的对象上。</p>
<p>这里有些避免发生类似问题的参考方法：</p>
<ul class="simple">
<li><p>避免对不同类型的对象使用同一个变量名</p></li>
</ul>
<p><strong>差</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;a string&#39;</span>
<span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>  <span class="c1"># 实现代码</span>
</pre></div>
</div>
<p><strong>好</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;a string&#39;</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">pass</span>  <span class="c1"># 实现代码</span>
</pre></div>
</div>
<p>使用简短的函数或方法能降低对不相关对象使用同一个名称的风险。即使是相关的不同
类型的对象，也更建议使用不同命名：</p>
<p><strong>差</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">items</span> <span class="o">=</span> <span class="s1">&#39;a b c d&#39;</span>  <span class="c1"># 首先指向字符串...</span>
<span class="n">items</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  <span class="c1"># ...变为列表</span>
<span class="n">items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>  <span class="c1"># ...再变为集合</span>
</pre></div>
</div>
<p>重复使用命名对效率并没有提升：赋值时无论如何都要创建新的对象。然而随着复杂度的
提升，赋值语句被其他代码包括 ‘if’ 分支和循环分开，使得更难查明指定变量的类型。
在某些代码的做法中，例如函数编程，推荐的是从不重复对同一个变量命名赋值。Java
内的实现方式是使用 ‘final’ 关键字。Python并没有 ‘final’ 关键字而且这与它的哲学
相悖。尽管如此，避免给同一个变量命名重复赋值仍是是个好的做法，并且有助于掌握
可变与不可变类型的概念。</p>
</div>
<div class="section" id="id19">
<h2>可变和不可变类型<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>Python提供两种内置或用户定义的类型。可变类型允许内容的内部修改。典型的动态类型
包括列表与字典：列表都有可变方法，如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">list.append()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">list.pop()</span></code>，
并且能就地修改。字典也是一样。不可变类型没有修改自身内容的方法。比如，赋值为整数
6的变量 x 并没有 “自增” 方法，如果需要计算 x + 1，必须创建另一个整数变量并给其命名。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">my_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nb">print</span> <span class="n">my_list</span>  <span class="c1"># [4, 2, 3] &lt;- 原列表改变了</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># x 变量是一个新的变量</span>
</pre></div>
</div>
<p>这种差异导致的一个后果就是，可变类型是不 ‘稳定 ‘的，因而不能作为字典的键使用。合理地
使用可变类型与不可变类型有助于阐明代码的意图。例如与列表相似的不可变类型是元组，
创建方式为 <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2)</span></code>。元组本身是不可修改的，若里面所有元素都是不可变类型，则能作为字典的键使用。</p>
<p>Python 中一个可能会让初学者惊讶的特性是：字符串是不可变类型。这意味着,
在从字符串的各个部分构造字符串时, 将每个部分追加到字符串上是效率低下的,
因为在每次追加时都会复制字符串的全部内容。
反之，将每一部分放到一个可变列表里，需要使用字符串时再粘合 (<code class="docutils literal notranslate"><span class="pre">join</span></code>) 起来的做法更高效。
列表推导通常是最快且最地道的方式来完成此目的。</p>
<p><strong>差</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建将0到19连接起来的字符串 (例 &quot;012..1819&quot;)</span>
<span class="n">nums</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">nums</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>   <span class="c1"># 慢且低效</span>
<span class="nb">print</span> <span class="n">nums</span>
</pre></div>
</div>
<p><strong>更好</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建将0到19连接起来的字符串 (例 &quot;012..1819&quot;)</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="nb">print</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># 更高效</span>
</pre></div>
</div>
<p><strong>最好</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建将0到19连接起来的字符串 (例 &quot;012..1819&quot;)</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="nb">print</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</pre></div>
</div>
<p>最后关于字符串的说明的一点是，使用 <code class="docutils literal notranslate"><span class="pre">join()</span></code> 并不总是最好的选择。比如当用预先
确定数量的字符串创建一个新的字符串时，使用加法操作符确实更快，但在上文提到的情况
下或添加到已存在字符串的情况下，使用 <code class="docutils literal notranslate"><span class="pre">join()</span></code> 是更好的选择。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
<span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>

<span class="n">foobar</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="n">bar</span>  <span class="c1"># 好的做法</span>
<span class="n">foo</span> <span class="o">+=</span> <span class="s1">&#39;ooo&#39;</span>  <span class="c1"># 不好的做法, 应该这么做:</span>
<span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;ooo&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>除了 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.join" title="(in Python v3.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">+</span></code>，您也可以使用 <a class="reference external" href="https://docs.python.org/3/library/string.html#string-formatting" title="(in Python v3.9)"><span class="xref std std-ref">%</span></a>
格式运算符来连接确定数量的字符串，但 <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a> 建议使用 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.format" title="(in Python v3.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>
替代 <code class="docutils literal notranslate"><span class="pre">%</span></code> 操作符。</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
<span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>

<span class="n">foobar</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="c1"># 可行</span>
<span class="n">foobar</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="c1"># 更好</span>
<span class="n">foobar</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{foo}{bar}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="n">bar</span><span class="p">)</span> <span class="c1"># 最好</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>提供依赖关系<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="runners">
<h2>Runners<a class="headerlink" href="#runners" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id21">
<h2>更多阅读<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="http://docs.python.org/3/library/">http://docs.python.org/3/library/</a></p></li>
<li><p><a class="reference external" href="https://diveintopython3.net/">https://diveintopython3.net/</a></p></li>
</ul>
</div>
</div>


          </div>
          
      </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="style.html" class="btn btn-neutral float-right" title="代码风格" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../dev/venv.html" class="btn btn-neutral float-left" title="虚拟环境" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2011-2021 &lt;a href=&#34;https://www.kennethreitz.org/projects&#34;&gt;Kenneth Reitz&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://realpython.com&#34;&gt;Real Python&lt;/a&gt;. &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-sa/3.0/&#34;&gt;CC BY-NC-SA 3.0&lt;/a&gt;.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<div class="footer">
  <div style="text-align: center;" id="waldo-tag-2171"></div>
  <p>&copy;2011-2021 <a href="https://www.kennethreitz.org/projects">Kenneth Reitz</a> &amp; <a href="https://realpython.com">Real Python</a>. <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a></p>
</div>


</body>
</html>